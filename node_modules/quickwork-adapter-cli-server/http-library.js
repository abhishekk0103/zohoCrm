let rp = require("request-promise");
var urlModule = require("url");

const ContentTypes = Object.freeze({
  JSON: "application/json",
  FORM_DATA: "multipart/form-data",
  FORM_URL_ENCODED: "application/x-www-form-urlencoded",
  BINARY: "application/octet-stream",
  XML: "text/xml",
  PLAIN_TEXT: "text/plain",
  MESSAGE_RFC: "message/rfc822",
  NULL: null,
});

const HTTPMethods = Object.freeze({
  GET: "GET",
  POST: "POST",
  PUT: "PUT",
  DELETE: "DELETE",
  PATCH: "PATCH",
  HEAD: "HEAD",
  COPY: "COPY",
  OPTIONS: "OPTIONS",
  LINK: "LINK",
  UNLINK: "UNLINK",
  PURGE: "PURGE",
  LOCK: "LOCK",
  UNLOCK: "UNLOCK",
  PROPFIND: "PROPFIND",
  VIEW: "VIEW",
});

const STATUS = Object.freeze({
  OK: { CODE: 200, TEXT: "OK" },
  CREATED: { CODE: 201, TEXT: "Created" },
  ACCEPTED: { CODE: 202, TEXT: "Accepted" },
  NO_CONTENT: { CODE: 204, TEXT: "No Content" },
  RESET_CONTENT: { CODE: 205, TEXT: "Reset Content" },
  PARTIAL_CONTENT: { CODE: 206, TEXT: "Partial Content" },
  MOVED_PERMANENTLY: { CODE: 301, TEXT: "Moved Permanently" },
  FOUND: { CODE: 302, TEXT: "Found" },
  SEE_OTHER: { CODE: 303, TEXT: "See Other" },
  NOT_MODIFIED: { CODE: 304, TEXT: "Not Modified" },
  USE_PROXY: { CODE: 305, TEXT: "Use Proxy" },
  TEMPORARY_REDIRECT: { CODE: 307, TEXT: "Temporary Redirect" },
  BAD_REQUEST: { CODE: 400, TEXT: "Bad Request" },
  UNAUTHORIZED: { CODE: 401, TEXT: "Unauthorized" },
  PAYMENT_REQUIRED: { CODE: 402, TEXT: "Payment Required" },
  FORBIDDEN: { CODE: 403, TEXT: "Forbidden" },
  NOT_FOUND: { CODE: 404, TEXT: "Not Found" },
  METHOD_NOT_ALLOWED: { CODE: 405, TEXT: "Method Not Allowed" },
  NOT_ACCEPTABLE: { CODE: 406, TEXT: "Not Acceptable" },
  PROXY_AUTHENTICATION_REQUIRED: {
    CODE: 407,
    TEXT: "Proxy Authentication Required",
  },
  REQUEST_TIMEOUT: { CODE: 408, TEXT: "Request Timeout" },
  CONFLICT: { CODE: 409, TEXT: "Conflict" },
  GONE: { CODE: 410, TEXT: "Gone" },
  LENGTH_REQUIRED: { CODE: 411, TEXT: "Length Required" },
  PRECONDITION_FAILED: { CODE: 412, TEXT: "Precondition Failed" },
  REQUEST_ENTITY_TOO_LARGE: { CODE: 413, TEXT: "Request Entity Too Large" },
  REQUEST_URI_TOO_LONG: { CODE: 414, TEXT: "Request-URI Too Long" },
  UNSUPPORTED_MEDIA_TYPE: { CODE: 415, TEXT: "Unsupported Media Type" },
  REQUESTED_RANGE_NOT_SATISFIABLE: {
    CODE: 416,
    TEXT: "Requested Range Not Satisfiable",
  },
  EXPECTATION_FAILED: { CODE: 417, TEXT: "Expectation Failed" },
  PRECONDITION_REQUIRED: { CODE: 428, TEXT: "Precondition Required" },
  TOO_MANY_REQUESTS: { CODE: 429, TEXT: "Too Many Requests" },
  REQUEST_HEADER_FIELDS_TOO_LARGE: {
    CODE: 431,
    TEXT: "Request Header Fields Too Large",
  },
  INTERNAL_SERVER_ERROR: { CODE: 500, TEXT: "Internal Server Error" },
  NOT_IMPLEMENTED: { CODE: 501, TEXT: "Not Implemented" },
  BAD_GATEWAY: { CODE: 502, TEXT: "Bad Gateway" },
  SERVICE_UNAVAILABLE: { CODE: 503, TEXT: "Service Unavailable" },
  GATEWAY_TIMEOUT: { CODE: 504, TEXT: "Gateway Timeout" },
  HTTP_VERSION_NOT_SUPPORTED: { CODE: 505, TEXT: "HTTP Version Not Supported" },
  NETWORK_AUTHENTICATION_REQUIRED: {
    CODE: 511,
    TEXT: "Network Authentication Required",
  },
});

const request = (
  url,
  headers,
  queryParams,
  method,
  body,
  contentType,
  oauth,
  encoding,
  timeout = 60000
) => {
  let options = {};

  if (timeout > 300000) {
    return {
      success: false,
      body: "Max timeout is 300000 milliseconds",
      statusCode: STATUS.INTERNAL_SERVER_ERROR.CODE,
    };
  }

  var queryObject = urlModule.parse(url, true).query;

  let urlParts = url.split("?");
  url = urlParts[0];

  if (queryParams == undefined || queryParams == null) {
    queryParams = queryObject;
  } else {
    for (let q in queryObject) {
      queryParams[q] = queryObject[q];
    }
  }

  if (method === undefined || method == null) method = HTTPMethods.GET;
  if (headers === undefined || method == null) headers = {};
  if (contentType === undefined || contentType == null)
    contentType = ContentTypes.JSON;

  if (contentType === ContentTypes.JSON) {
    options["json"] = true;
    if (body != undefined && body != null) options["body"] = body;
  }

  if (contentType === ContentTypes.FORM_DATA) {
    options["formData"] = body;
  }

  if (contentType === ContentTypes.FORM_URL_ENCODED) {
    options["form"] = body;
  }

  if (
    contentType === ContentTypes.PLAIN_TEXT ||
    contentType === ContentTypes.XML
  ) {
    options["body"] = body;
  }

  if (queryParams != undefined && queryParams != null) {
    options["qs"] = queryParams;
  }

  if (oauth != undefined && oauth != null) {
    options["oauth"] = oauth;
  }

  options["transform"] = function (body, response, resolveWithFullResponse) {
    return {
      headers: response.headers,
      body: body,
      statusCode: response.statusCode,
    };
  };

  options["method"] = method;
  options["url"] = url;

  if (headers != undefined && headers != null) {
    options["headers"] = headers;
  }

  if (
    contentType === ContentTypes.PLAIN_TEXT ||
    contentType === ContentTypes.XML
  ) {
    options["headers"]["content-type"] = contentType;
  }

  if (!(encoding === undefined)) {
    options.encoding = encoding;
  }

  options["timeout"] = timeout;

  return rp(options)
    .then((success) => {
      return {
        success: true,
        body: success.body,
        headers: success.headers == undefined ? {} : success.headers,
        statusCode: success.statusCode,
      };
    })
    .catch((error) => {
      try {
        return {
          success: false,
          body: error.response.body,
          headers:
            error.response.headers == undefined ? {} : error.response.headers,
          statusCode: error.statusCode,
        };
      } catch (internalError) {
        return {
          success: false,
          body: error.message,
          statusCode: STATUS.INTERNAL_SERVER_ERROR.CODE,
        };
      }
    });
};

const successResponse = (response, statusCode) => {
  if (typeof response == "object" && !Array.isArray(response))
    removeEmpty(response);

  if (statusCode === undefined || statusCode == null)
    statusCode = STATUS.OK.CODE;
  return {
    success: true,
    statusCode,
    response,
  };
};

const errorResponse = (message, statusCode) => {
  if (statusCode === undefined) statusCode = STATUS.INTERNAL_SERVER_ERROR.CODE;
  if (message === undefined || message == null)
    message = STATUS.INTERNAL_SERVER_ERROR.TEXT;

  if (Number.isInteger(statusCode)) {
    if (statusCode >= STATUS.OK.CODE && statusCode < STATUS.BAD_REQUEST.CODE)
      statusCode = STATUS.INTERNAL_SERVER_ERROR.CODE;
  }

  if (typeof message == "object") {
    if (!Array.isArray(message)) removeEmpty(message);

    message = JSON.stringify(message);
  }

  return {
    success: false,
    statusCode,
    errorMessage: message,
  };
};

const contextResponse = (response, context, statusCode) => {
  if (statusCode === undefined || statusCode == null)
    statusCode = STATUS.OK.CODE;
  return {
    success: true,
    statusCode,
    response,
    context,
  };
};

const removeEmpty = (obj) => {
  Object.keys(obj).forEach(function (key) {
    if (obj[key] && typeof obj[key] === "object") removeEmpty(obj[key]);
    else if (obj[key] == null) delete obj[key];
  });
};

const isValidJsonString = (str) => {
  try {
    let json = JSON.parse(str);
    if (typeof json == "object") {
      if (json) {
        return { isValidJSON: true, json };
      }
      return { isValidJSON: false };
    } else {
      return { isValidJSON: false };
    }
  } catch (e) {
    return { isValidJSON: false };
  }
};

let HttpUtils = {
  request,
  ContentTypes,
  HTTPMethods,
  successResponse,
  errorResponse,
  contextResponse,
  removeEmpty,
};

module.exports = {
  HttpUtils,
  STATUS,
  isValidJsonString,
};
